<!DOCTYPE html>
<html lang="en">
	<head>
		<title>bi</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="bi.css">
	</head>
	<body>

		<div id="info">
			<h1>belleisle</h1>
		</div>
    <div id="container">

    </div>
		<!-- <div class="sidebar">
			<h2></h2>
			<h2></h2>
			<h2></h2>
			<h2></h2>
		</div> -->


    


		<script type="module">

import * as THREE from 'https://unpkg.com/three@0.142.0/build/three.module.js';

import Stats from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/libs/stats.module.js';
import { GUI } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/libs/dat.gui.module.js';

import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js'


let container, stats, guiStatsEl;
    // let gui
let camera, light, backlight, controls, scene, renderer, material;

// gui

const Method = {
  INSTANCED: 'INSTANCED',
  MERGED: 'MERGED',
  NAIVE: 'NAIVE'
};

const api = {
  method: Method.INSTANCED,
  count: 1000
};

//

init();
    // initmediaobj();
// initMesh();
animate();


const aerialgroup = new THREE.Group();
const drawinggroup = new THREE.Group();

var loader = new THREE.TextureLoader();
        const mapgeo = new THREE.PlaneGeometry(30,21);
        const mapmaterial = new THREE.MeshBasicMaterial({map: loader.load("map.png"), transparent:true});
        const map2material = new THREE.MeshBasicMaterial({map: loader.load("basemap.png"), transparent:true})

        const map = new THREE.Mesh(mapgeo,mapmaterial);
        // map.rotation.y= 0.5*Math.PI;
        const map2 = new THREE.Mesh(mapgeo,map2material);
        // map.position.=0;
        // map2.position.z=1;
	mapmaterial.alphaTest = 0.5;
        map2material.alphaTest = 0.5;
        
        aerialgroup.add(map);
        drawinggroup.add(map2);
			
	var particles = 40777;
        let positions = [];
        var geometry = new THREE.BufferGeometry();
        var n = 50, n2 = n / 2; 
        var materialpoints = new THREE.PointsMaterial( { map: loader.load("water.png"), transparent:true,  size: 0.5, vertexColors: false } );

        for ( var i = 0; i < particles; i ++ ) {
            var x = Math.random() * n - n2;
            var y = Math.random() * n - n2;
            var z = -1;
            positions.push( x, y, z );

        }
        geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
        geometry.computeBoundingSphere();
        const water = new THREE.Points( geometry, materialpoints );
    
        drawinggroup.add(water);


    scene.add(drawinggroup);
    var params = {
				scene: "drawing"
			};
const gui = new GUI();

gui.add(params,'scene',['aerial map', 'drawing']).onChange( function (value){
  switch(value){
    case 'aerial map': scene.add(aerialgroup);
                        scene.remove(drawinggroup);
                        break;
    case 'drawing': scene.remove(aerialgroup);
                        scene.add(drawinggroup);   
                        break;             
  }
})


function init() {

  const width = window.innerWidth;
  const height = window.innerHeight;

  // camera

//   camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / -2, 1, 100 );
camera = new THREE.PerspectiveCamera( 50, width / height, 1, 100 );

  camera.position.z = 40;
//   camera.position.y = 0;

//   camera.position.x = 0;

        //light
        light = new THREE.AmbientLight( 0xffffff, 1 );
  // backlight = new THREE.DirectionalLight( 0xffffff, 1 );

        light.position.set( 0, 0, 10 ).normalize();
        // backlight.position.set( 0, 0, -10 ).normalize();

  // renderer

  renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( width, height );
  renderer.outputEncoding = THREE.sRGBEncoding;

  container = document.getElementById( 'container' );
  container.appendChild( renderer.domElement );

  // scene

  scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x000000 );

  // controls

  controls = new OrbitControls( camera, renderer.domElement );
  controls.enableRotate = false
  // controls.autoRotate = true;

  // stats

  stats = new Stats();
  container.appendChild( stats.dom );


        scene.add(light)


  window.addEventListener( 'resize', onWindowResize );

  Object.assign( window, { scene } );

}

//

function onWindowResize() {

  const width = window.innerWidth;
  const height = window.innerHeight;

  camera.aspect = width / height;
  camera.updateProjectionMatrix();

  renderer.setSize( width, height );

}

function animate() {

  requestAnimationFrame( animate );

  controls.update();
  stats.update();

  render();

}

function render() {

  renderer.render( scene, camera );

}

//

function getGeometryByteLength( geometry ) {

  let total = 0;

  if ( geometry.index ) total += geometry.index.array.byteLength;

  for ( const name in geometry.attributes ) {

    total += geometry.attributes[ name ].array.byteLength;

  }

  return total;

}

// Source: https://stackoverflow.com/a/18650828/1314762
function formatBytes( bytes, decimals ) {

  if ( bytes === 0 ) return '0 bytes';

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = [ 'bytes', 'KB', 'MB' ];

  const i = Math.floor( Math.log( bytes ) / Math.log( k ) );

  return parseFloat( ( bytes / Math.pow( k, i ) ).toFixed( dm ) ) + ' ' + sizes[ i ];

}
		</script>

	</body>

</html>
